import { getConfig } from '../config/aiAssistantConfig';
import { aiApiRequest } from '../data/infrastructure/apiClient.js';
import { dataFacade } from '../data/DataFacade.js';
import { socketFacade } from '../data/SocketFacade.js';

// Logger utility
class Logger {
  static log(level, message, data = null) {
    if (!getConfig('LOGGING.ENABLED')) return;
    
    const logLevel = getConfig('LOGGING.LEVEL');
    const levels = { debug: 0, info: 1, warn: 2, error: 3 };
    
    if (levels[level] >= levels[logLevel]) {
      const timestamp = new Date().toISOString();
      const logMessage = `[AI Assistant ${level.toUpperCase()}] ${timestamp}: ${message}`;
      
      if (getConfig('LOGGING.SHOW_CONSOLE')) {
        switch (level) {
          case 'debug':
            console.debug(logMessage, data);
            break;
          case 'info':
            console.info(logMessage, data);
            break;
          case 'warn':
            console.warn(logMessage, data);
            break;
          case 'error':
            console.error(logMessage, data);
            break;
        }
      }
    }
  }
}

// AI Assistant Service Class
export class AIAssistantService {
  constructor(businessId, userId, locationId = null) {
    this.businessId = businessId;
    this.userId = userId;
    this.locationId = locationId || getConfig('DEFAULTS.LOCATION_ID');
    this.currentSessionId = null;
    this.messageHistory = [];
    this.isConnected = false;
    this.reconnectAttempts = 0;
    this.heartbeatInterval = null;
    this.isDemoMode = import.meta.env.VITE_DEMO_MODE === 'true';
    
    // Event callbacks
    this.onMessageReceived = null;
    this.onConnectionChange = null;
    this.onSessionChange = null;
    this.onError = null;
    
    // DataFacade and SocketFacade integration
    this.dataFacade = dataFacade;
    this.socketFacade = socketFacade;
    
    Logger.log('info', 'AI Assistant Service initialized', { businessId, userId, locationId });
  }

  // Generate session ID for daily sessions (DEPRECATED - use server-generated IDs)
  // This method is kept for backward compatibility but should not be used
  // Session IDs should be generated by the server
  generateSessionId() {
    console.warn('generateSessionId() is deprecated. Session IDs should be generated by the server.');
    return this.dataFacade.generateAIAssistantSessionId(this.businessId, this.userId);
  }

  // Load today's session
  async loadTodaySession() {
    try {
      Logger.log('info', 'Loading today session');
      
      // First, try to get active session for user
      const activeSession = await this.dataFacade.getActiveAIAssistantSessionForUser(this.businessId, this.userId);
      
      if (activeSession) {
        // Use existing active session
        this.currentSessionId = activeSession.sessionId;
        Logger.log('info', 'Found active session', { sessionId: this.currentSessionId });
        
        // Load message history for existing session
        await this.loadMessageHistory(this.currentSessionId);
        
        // Send session loaded event via SocketFacade
        this.socketFacade.sendAIAssistantSessionLoaded(this.businessId, this.userId, this.currentSessionId, this.locationId);
        
        // Notify session change
        this.onSessionChange?.(this.currentSessionId);
        
        return this.currentSessionId;
      } else {
        // No active session found, request server to create new one
        Logger.log('info', 'No active session found, requesting server to create new session');
        
        // Request server to create new session
        const session = await this.dataFacade.loadTodayAIAssistantSession(this.businessId, this.userId, this.locationId);
        
        // Server should return the session with the sessionId
        this.currentSessionId = session.sessionId;
        
        Logger.log('info', 'Server created new session', { sessionId: this.currentSessionId });
        
        // Load message history for the new session
        await this.loadMessageHistory(this.currentSessionId);
        
        // Send session loaded event via SocketFacade
        this.socketFacade.sendAIAssistantSessionLoaded(this.businessId, this.userId, this.currentSessionId, this.locationId);
        
        // Notify session change
        this.onSessionChange?.(this.currentSessionId);
        
        return this.currentSessionId;
      }
    } catch (error) {
      Logger.log('error', 'Failed to load today session', error);
      this.onError?.(getConfig('ERRORS.SESSION_LOAD_FAILED'), error);
      throw error;
    }
  }

  // Load message history for a session
  async loadMessageHistory(sessionId, limit = null, before = null) {
    try {
      // In demo mode, return mock message history
      if (this.isDemoMode) {
        this.messageHistory = [
          {
            messageId: 'demo-msg-1',
            sessionId: sessionId,
            content: 'Bună! Sunt AI Assistant-ul în modul demo. Cum vă pot ajuta astăzi?',
            timestamp: new Date(Date.now() - 1000 * 60 * 30).toISOString(),
            type: 'assistant'
          }
        ];
        
        // Notify about loaded messages
        this.onMessageReceived?.(this.messageHistory);
        return;
      }

      let endpoint = `${getConfig('API_ENDPOINTS.SESSIONS')}/${sessionId}/messages`;
      
      const params = new URLSearchParams();
      if (limit) params.append('limit', limit);
      if (before) params.append('before', before);
      
      if (params.toString()) {
        endpoint += `?${params.toString()}`;
      }
      
      const data = await aiApiRequest(endpoint);
      this.messageHistory = data.messages || [];
      
      Logger.log('info', 'Message history loaded', { 
        sessionId, 
        messageCount: this.messageHistory.length 
      });
      
      // Notify about loaded messages
      this.onMessageReceived?.(this.messageHistory);
      
      return this.messageHistory;
    } catch (error) {
      Logger.log('error', 'Failed to load message history', error);
      this.onError?.(getConfig('ERRORS.SESSION_LOAD_FAILED'), error);
      throw error;
    }
  }

  // Send message to AI
  async sendMessage(content, context = {}) {
    if (!this.currentSessionId) {
      throw new Error('No active session');
    }

    if (!content || content.trim().length === 0) {
      throw new Error('Message content cannot be empty');
    }

    if (content.length > getConfig('MESSAGE.MAX_LENGTH')) {
      throw new Error(`Message too long. Maximum ${getConfig('MESSAGE.MAX_LENGTH')} characters allowed.`);
    }

    try {
      Logger.log('debug', 'Sending message via DataFacade', { content, context });

      // Use DataFacade to send message
      const result = await this.dataFacade.sendAIAssistantRepositoryMessage(
        this.currentSessionId,
        content,
        context,
        this.businessId,
        this.userId,
        this.locationId
      );
      
      if (result.status === 'success') {
        Logger.log('info', 'Message sent successfully', result);
        
        // Add user message to history
        const userMessage = {
          messageId: result.messageId || result.message?.messageId || `user_${Date.now()}`,
          sessionId: this.currentSessionId,
          businessId: this.businessId,
          userId: this.userId,
          content: content.trim(),
          type: 'user',
          timestamp: new Date().toISOString(),
          metadata: { source: 'api' }
        };
        
        this.messageHistory.push(userMessage);
        this.onMessageReceived?.([userMessage]);
        
        return result;
      } else {
        throw new Error(result.message || 'Unknown error occurred');
      }
    } catch (error) {
      Logger.log('error', 'Failed to send message', error);
      this.onError?.(getConfig('ERRORS.MESSAGE_SEND_FAILED'), error);
      throw error;
    }
  }

  // Get active sessions for business
  async getActiveSessions() {
    try {
      return await this.dataFacade.getActiveAIAssistantSessions(this.businessId);
    } catch (error) {
      Logger.log('error', 'Failed to get active sessions', error);
      this.onError?.('Failed to retrieve active sessions', error);
      throw error;
    }
  }

  // Get active session for current user
  async getActiveSessionForUser() {
    try {
      return await this.dataFacade.getActiveAIAssistantSessionForUser(this.businessId, this.userId);
    } catch (error) {
      Logger.log('error', 'Failed to get active session for user', error);
      this.onError?.('Failed to retrieve active session for user', error);
      throw error;
    }
  }

  // Get user session history
  async getUserSessionHistory(limit = 20) {
    try {
      return await this.dataFacade.getUserAIAssistantSessionHistory(this.businessId, this.userId, limit);
    } catch (error) {
      Logger.log('error', 'Failed to get user session history', error);
      this.onError?.('Failed to retrieve user session history', error);
      throw error;
    }
  }

  // Get session by ID
  async getSessionById(sessionId) {
    try {
      return await this.dataFacade.getAIAssistantSessionById(sessionId);
    } catch (error) {
      Logger.log('error', 'Failed to get session by ID', error);
      this.onError?.('Failed to retrieve session', error);
      throw error;
    }
  }

  // Load specific session
  async loadSession(sessionId) {
    try {
      const sessionData = await this.dataFacade.loadAIAssistantSession(sessionId);
      
      if (sessionData) {
        this.currentSessionId = sessionId;
        this.messageHistory = sessionData.messages || [];
        
        // Send session loaded event via SocketFacade
        this.socketFacade.sendAIAssistantSessionLoaded(this.businessId, this.userId, sessionId, this.locationId);
        
        // Notify session change
        this.onSessionChange?.(sessionId);
        
        // Notify about loaded messages
        this.onMessageReceived?.(this.messageHistory);
      }
      
      return sessionData;
    } catch (error) {
      Logger.log('error', 'Failed to load session', error);
      this.onError?.('Failed to load session', error);
      throw error;
    }
  }

  // Close current session
  async closeSession(status = 'resolved') {
    if (!this.currentSessionId) {
      Logger.log('warn', 'No active session to close');
      return;
    }

    try {
      const result = await this.dataFacade.closeAIAssistantSession(this.currentSessionId, status);

      Logger.log('info', 'Session closed', { 
        sessionId: this.currentSessionId, 
        status 
      });

      // Send session closed event via SocketFacade
      this.socketFacade.sendAIAssistantSessionClosed(this.currentSessionId, status);

      // Clear current session
      this.currentSessionId = null;
      this.onSessionChange?.(null);
      
      return result;
    } catch (error) {
      Logger.log('error', 'Failed to close session', error);
      this.onError?.('Failed to close session', error);
      throw error;
    }
  }

  // Get session statistics
  async getSessionStats() {
    try {
      const stats = await this.dataFacade.getAIAssistantSessionStats(this.businessId);
      
      // Send stats event via SocketFacade
      this.socketFacade.sendAIAssistantStats(this.businessId, stats);
      
      return stats;
    } catch (error) {
      Logger.log('error', 'Failed to get session statistics', error);
      this.onError?.('Failed to retrieve session statistics', error);
      throw error;
    }
  }

  // Search messages in current session
  async searchMessages(query, limit = 20) {
    if (!this.currentSessionId) {
      throw new Error('No active session');
    }

    try {
      const results = await this.dataFacade.searchAIAssistantMessages(this.currentSessionId, query, limit);
      
      // Send search event via SocketFacade
      this.socketFacade.sendAIAssistantMessageSearch(
        this.currentSessionId, 
        query, 
        limit, 
        results?.length || 0
      );
      
      return results;
    } catch (error) {
      Logger.log('error', 'Failed to search messages', error);
      this.onError?.('Failed to search messages', error);
      throw error;
    }
  }

  // Export session data
  async exportSession(format = 'json') {
    if (!this.currentSessionId) {
      throw new Error('No active session');
    }

    try {
      const exportData = await this.dataFacade.exportAIAssistantSession(this.currentSessionId, format);
      
      // Send export event via SocketFacade
      this.socketFacade.sendAIAssistantSessionExport(
        this.currentSessionId, 
        format, 
        exportData?.length || 0
      );
      
      return exportData;
    } catch (error) {
      Logger.log('error', 'Failed to export session', error);
      this.onError?.('Failed to export session', error);
      throw error;
    }
  }

  // Cleanup and dispose
  dispose() {
    Logger.log('info', 'AI Assistant Service disposed');
    
    // Clear intervals
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }
    
    // Clear callbacks
    this.onMessageReceived = null;
    this.onConnectionChange = null;
    this.onSessionChange = null;
    this.onError = null;
    
    // Clear data
    this.messageHistory = [];
    this.currentSessionId = null;
    this.isConnected = false;
  }
}

// Factory function to create AI Assistant Service
export const createAIAssistantService = (businessId, userId, locationId = null) => {
  return new AIAssistantService(businessId, userId, locationId);
};

// Utility functions
export const formatSessionId = (businessId, userId, timestamp) => {
  return `${businessId}:${userId}:${timestamp}`;
};

export const parseSessionId = (sessionId) => {
  const parts = sessionId.split(':');
  if (parts.length !== 3) {
    throw new Error('Invalid session ID format');
  }
  
  return {
    businessId: parts[0],
    userId: parts[1],
    timestamp: parseInt(parts[2])
  };
};

export const isValidSessionId = (sessionId) => {
  try {
    parseSessionId(sessionId);
    return true;
  } catch {
    return false;
  }
};
